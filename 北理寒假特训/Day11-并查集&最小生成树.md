# 并查集

![image-20200722171914257](mdPics/image-20200722171914257.png)

解决方法：

1. 图染色，合并复杂度高，查询O（1）；
2. 并查集；

## 概念

![image-20200722172454545](mdPics/image-20200722172454545.png)

## 实现

1. 数组实现

建立标记数组father，用father[]表示元素i所属集合(头目)的标记。

![image-20200722173132900](mdPics/image-20200722173132900.png)

![image-20200722173219892](mdPics/image-20200722173219892.png)

看到这里突然感觉和Dijkstra记录路径的方法类似

![image-20200722173638490](mdPics/image-20200722173638490.png)

![image-20200722173801389](mdPics/image-20200722173801389.png)

## 优化

对整体数据结构的优化，在find函数中优化。

![image-20200722174038865](mdPics/image-20200722174038865.png)

树状结构可能变成线状结构。

![image-20200722174255128](mdPics/image-20200722174255128.png)

![image-20200722174442930](mdPics/image-20200722174442930.png)

一般写递归即可。复杂度log级。

![image-20200722174519552](mdPics/image-20200722174519552.png)

![image-20200722175016500](mdPics/image-20200722175016500.png)

![image-20200722175044830](mdPics/image-20200722175044830.png)

![image-20200722175115934](mdPics/image-20200722175115934.png)

## 变种

![image-20200722175133950](mdPics/image-20200722175133950.png)

![image-20200722180530787](mdPics/image-20200722180530787.png)

# 最小生成树

![image-20200722180650851](mdPics/image-20200722180650851.png)

## kruskal算法

![image-20200722180808260](mdPics/image-20200722180808260.png)

![image-20200722180912925](mdPics/image-20200722180912925.png)

### 实现

![image-20200722180957456](mdPics/image-20200722180957456.png)

使用路径压缩，平均复杂度ElogE

## prim算法

![image-20200722181123108](mdPics/image-20200722181123108.png)

用的不多。和Dijkstra有点像。

![image-20200722182128936](mdPics/image-20200722182128936.png)

![image-20200722182207614](mdPics/image-20200722182207614.png)